<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>CSS Layout Exercice</title>
  </head>
  <body>

<h2>Inline</h2>
    <span>Un span est un élement inline Un élément inline peut encadrer du texte dans un paragraphe <(span> comme ceci <(/span> sans interrompre le flux de ce paragraphe.<br>
     L'élément a est l'élément inline le plus courant, puisque vous l'utilisez pour vos liens.</span>
<h2>None</h2>
     <p class="display-none">Tututu tu ne me vois pas! :p c'est normal je suis sur display: none;</p>
     <p>Une autre valeur display courante est none. Quelques éléments spéciaux comme script l'utilisent par défaut. display: none; est très utile pour masquer ou afficher facilement des éléments en CSS ou en Javascripts sans avoir à les supprimer et les recréer dans le DOM.
     <br>Ne confondez pas display: none; et visibility: hidden; ! display: none; masque totalement l'élément et annule des propriétés telles que margin, padding, width, height...tandis que visibility: hidden; masque seulement l'élément, ce qui peut laisser des espaces vides.</p>
<h2>d'autre valeur pour display</h2>
     <p>Display possède une quantité d'autres valeurs exotiques, comme list-item et table. Voici une liste exhaustive. Nous discuterons de inline-block et flex plus tard.</p>
<h2>Bonus</h2>
      <ul class="bonus">
        <li>Comme je le disais, chaque élément a un type display par défaut.</li>
        <li>Cependant, vous pouvez toujours les écraser ! </li>
        <li>Même si ça n'a pas beaucoup de sens de rendre une div inline, vous pouvez faire cela pour customiser des éléments qui ont une sémantique particulière.</li>
        <li>Un exemple courant est de rendre inline les éléments li pour faire des menus horizontaux. </li>
      </ul>
<h2>Margin auto</h2>
      <div id="main">
        <p>Attribuer une width à un élément block-level l'empêchera de s'étirer sur toute la largeur de son conteneur.
          <br>Ensuite vous pouvez mettre la valeur auto aux propriétés margin-right et margin-left pour centrer horizontallement cet élément à l'intérieur de son conteneur.
          <br>L'élément prendra la largeur que vous avez spécifié et l'espace restant sera séparé équitablement entre les deux marges.
          <br>Le seul problème survient lorsque la fenêtre du navigateur est plus petite que la largeur de votre élément.
          <br>Le navigateur résout cela en créant une barre de défilement (scrollbar) horizontale. Améliorons cette situation...
        </p>
      </div>
<h2>max-width</h2>
      <div id="main">
        <p>Utiliser max-width à la place de width améliorera la gestion des petites fenêtres. C'est très important lorsque l'on créé un site accessible sur mobile. Redimensionnez cette page pour voir !

          Au fait, max-width est supporté par tous les navigateurs majeurs incluant IE7+, vous ne devez donc pas avoir peur de l'utiliser.
        </p>
      </div>

    <style>
    div {
      display: block;
      border: 2px grey solid;
    }

    .display-none {
      display: none;
    }
    .bonus li {
      display: inline;
    }

    #main {
      width: 400px;
      margin-left: auto;
      margin-right: auto;
      max-width: 600px;
    }
    </style>

    <h2>box-model</h2>
        <p>Si nous parlons de la propriété width, nous devrions parler du box model. Quand vous ajustez la propriété width d'un élément, celui-ci peut paraître plus gros que ce que vous avez indiqué : la bordure et le padding de l'élément l'étirent au delà de la largeur spécifiée. Regardez l'exemple suivant, où deux éléments ayant la même largeur se retrouvent avec deux tailles différentes.
        </p>

      <div class="simple">
        <p>Je suis plus petit...
        <br> Hourra!</p>
      </div>
      <style>
      .simple {
        width: 500px;
        margin: 20px auto;
        -webkit-box-sizing: border-box;
     -moz-box-sizing: border-box;
          box-sizing: border-box;
      }
      </style>
      <div class="fancy">
        <p>Je suis plus grand!
        <br> Maintenant je suis à la bonne taille</p>
      </div>
      <style>
      .fancy{
        width: 500px;
        margin: 20px auto;
        padding: 50px;
        border-width: 10px;
        -webkit-box-sizing: border-box;
     -moz-box-sizing: border-box;
          box-sizing: border-box;
      }
      </style>
<h2>Box-sizing</h2>
<p>Au fil du temps, les gens se sont rendus compte que les maths ce n'était pas marrant, donc une nouvelle propriété CSS appelée box-sizing fût créée.
  <br>Quand vous ajoutez la propriété box-sizing: border-box; à un élément, le padding et la bordure de cet élément n'augmentent plus sa largeur.
  <br>Ci-dessous, le même exemple que dans la page précédente, mais avec la propriété box-sizing: border-box; sur les deux éléments :
</p>

<h1>Position</h1>
<p>Pour des mise en page plus complexes, nous devons parler de la propriété CSS position.
  <br>Elle a plusieurs valeurs possibles, et leurs noms n'ont aucun sens et sont impossible à retenir.
  <br>Voyons-les une par une, mais peut-être devriez-vous ajouter cette page à vos favoris.
</p>

<h2>Static</h2>
    <div class="static">
      <p>static est la valeur par défaut de tous les éléments. Un élément avec position: static; n'est positionné d'aucune manière spéciale. Un élément static est dit non positionné et un élément avec une propriété position ayant une valeur autre que static est dit positionné.
      </p>
    <style>
    .static {
      position: static;
    }
    </style>

<h2>Relative</h2>
    <div class="relative1">
      <p>relative se comporte de la même façon que static sauf si vous ajoutez quelques propriétés en plus.
      </p>
    </div>

    <style>
          .relative1. {
            position: relative;
          }
    </style>
    <div class="relative2">
      <p>Ajouter les propriétés top, right, bottom et left à un élément positionné en relative va le placer ailleurs que sa position normale. Le reste du contenu ne sera pas ajusté pour prendre la place dans l'espace laissé par l'élément
      </p>
    </div>
<style>
.relative2{
  position: relative;
  top: -20px;
  left: 20px;
  background-color: grey;
  width: 500px;

}
</style>
<p>Un élément positionné en fixed est positionné par rapport a la fenêtre du navigateur, ce qui signifie qu'il reste toujours à la même place même si la page défile. De la même manière qu'avec un élément positionné en relative, nous pouvons utiliser les propriétés top, right, bottom et left.

Je suis sûr que vous avez remarqué cet élément fixe dans le coin en bas à droite de la page. Je vous autorise à le regarder maitenant. Voici le CSS qui l'a placé là.
</p>
<div class="fixed">
  <p>Bonjour ! Ne faites pas attention à moi pour l'instant.</p>
</div>

<style>
.fixed {
  position:fixed;
  bottom: 0;
  right: 0;
  width: 50px;
  background-color: white;
}
</style>

<p>absolute est la valeur la plus délicate. absolute se comporte comme fixed sauf que son positionnement est relatif à l'élément parent positionné le plus proche au lieu d'être relatif à la fenêtre du navigateur. Si un élément positionné en absolute n'à aucun élément parent positionné, il utilise le corps du document et se déplace avec le document au défilement de la page.
  <br> N'oubliez-pas qu'un élément "positionné" est un élément dont la position est tout sauf static.
</p>
<div class="relative">
  <p>Cet élément est positionné en relative. S'il était positionné en position: static; son élément enfant positionné en absolute s'échapperait et serait positionné de manière relative au corps du document.
  </p>
  <div class="absolute">
    <p>Cet élément est positionné en absolute. Sa position est relative à son parent.</p>
  </div>
</div>

<style>
.relative {
  position: relative;
    width: 600px;
    height: 400px;
}
.absolute {
  position: absolute;
  top: 120px;
  right: 0;
  width: 300px;
  height: 200px;
  background-color: red;
}
</style>
</body>
</html>
